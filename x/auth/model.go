package auth

import (
	"encoding/json"
	"fmt"

	"github.com/confio/weave"
	crypto "github.com/tendermint/go-crypto"
)

//----------------- Model ------------------
//
// Model stores the persistent state and all domain logic
// associated with valid state and state transitions.
// As well as how to de/serialize it from the persistent store.
//
// If does not care about when to change state or who is authorized
// (that belongs in the controller), but rather with what possible
// states are valid.

//------------------ Serialization ------------------------

//---- Key

// UserKey is the primary key we use to distinguish users
// This should be []byte, in order to index with our KVStore.
// Any structure to these bytes should be defined by the constructor.
//
// Question: allow objects with a Marshal method???
type UserKey []byte

var userPrefix = []byte("user:")

// NewUserKey constructs the user key from a key hash,
// by appending a prefix.
func NewUserKey(keyHash weave.KeyHash) UserKey {
	bz := append(userPrefix, keyHash...)
	return UserKey(bz)
}

//---- Data

// UserData just stores the data and is used for serialization.
// It may be auto-generated by eg. protobuf,
// encoded using reflect (json, go-wire),
// or have a hand-crafted marshalling methods
//
// Note: This should not be created from outside the module,
// User is the entry point you want
type UserData struct {
	PubKey   crypto.PubKey
	Sequence int64
}

// Marshal must know how to serialize this struct
func (u UserData) Marshal() ([]byte, error) {
	// TODO: real codec
	return json.Marshal(u)
}

// Unmarshal must know how to deserialize this struct
func (u *UserData) Unmarshal(bz []byte) error {
	// TODO: real codec
	return json.Unmarshal(bz, u)
}

// Validate must determine if this is a legal state
// (eg. all required fields set, sequence non-negative, etc.)
//
// Returns an explanation if the data is invalid
func (u UserData) Validate() error {
	if u.Sequence < 0 {
		// TODO: ErrInvalidSequence
		return fmt.Errorf("Sequence is negative")
	}
	if u.Sequence > 0 && u.PubKey.Empty() {
		// TODO: ErrInvalidSequence
		return fmt.Errorf("Positive Sequence must have a PubKey")
	}
	return nil
}

//------------------ High-Level ------------------------

// User is the actual object that we want to pass around in our code.
// It handles loading and saving the data to/from the persistent store.
// It also adds helpers to manipulate state.
//
// It may allow full access to manipulate all variables on the data,
// or limit it. It maintains a reference to the store it was loaded
// from, to know how to save itself.
type User struct {
	store weave.KVStore
	key   UserKey
	data  UserData
}

// GetUser loads this user if present, or returns nil if missing
func GetUser(store weave.KVStore, key UserKey) *User {
	bz := store.Get(key)
	if bz == nil {
		return nil
	}

	var data UserData
	// TODO: MustUnmarshal
	err := data.Unmarshal(bz)
	if err != nil {
		panic(err)
	}

	return &User{
		store: store,
		key:   key,
		data:  data,
	}
}

// GetOrCreateUser loads this user if present,
// or initializes a new user with this key if not present.
func GetOrCreateUser(store weave.KVStore, key UserKey) *User {
	res := GetUser(store, key)
	if res == nil {
		res = &User{
			store: store,
			key:   key,
			data:  UserData{},
		}
	}
	return res
}

// Save writes the current user state to the backing store
// panics if invalid state
func (u *User) Save() {
	// TODO: MustValidate
	err := u.data.Validate()
	if err != nil {
		panic(err)
	}

	// TODO: MustMarshal
	value, err := u.data.Marshal()
	if err != nil {
		panic(err)
	}

	u.store.Set(u.key, value)
}

// Delete removes the current user id from the backing store
// panics if key is missing
func (u *User) Delete() {
	u.store.Delete(u.key)
}

// GetPubKey checks the current pubkey for this account
func (u User) GetPubKey() crypto.PubKey {
	return u.data.PubKey
}

// GetSequence checks the current sequence for this account
func (u User) GetSequence() int64 {
	return u.data.Sequence
}

// CheckAndIncrementSequence checks if the current Sequence
// matches the expected value.
// If so, it will increase the sequence by one and return nil
// If not, it will not change the sequence, but return an error
func (u User) CheckAndIncrementSequence(check int64) error {
	if u.data.Sequence != check {
		// TODO: ErrInvalidSequence
		return fmt.Errorf("Invalid sequence number %d (actual %d)",
			check, u.data.Sequence)
	}
	u.data.Sequence++
	return nil
}

// SetPubKey will try to set the PubKey or panic on an illegal operation.
// It is illegal to reset an already set key
// Otherwise, we don't control
// (although we could verify the hash, we leave that to the controller)
func (u User) SetPubKey(pubKey crypto.PubKey) {
	if !u.data.PubKey.Empty() {
		panic("Cannot change pubkey for a user")
	}
	u.data.PubKey = pubKey
}

//--------------- Ideas for the future???? ----------

// WithStore makes a copy of this User with a different backing store.
// This can be used if we modify an item, then pass it down over
// a savepoint. If the savepoint commits, the new value will have been
// saved. If it fails, we can save the original user.
//
// However, this may all be over complex, and just let the caller save
// the data first, then the callee can call if needed. Do we really
// pass objects over savepoint boundaries often or at all???
// func (u *User)WithStore(store weave.KVStore) *User {
// }
